package org.usfirst.frc329.beta20191.subsystems;

import org.usfirst.frc329.beta20191.commands.*;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SerialPort;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.SpeedControllerGroup;

public class sDrive extends Subsystem {

    private WPI_TalonSRX talonSRXLeft3;
    private WPI_VictorSPX victorSPXLeft4;
    private WPI_VictorSPX victorSPXLeft5;
    private SpeedControllerGroup speedControllerLeft;
    private WPI_TalonSRX talonSRXRight0;
    private WPI_VictorSPX victorSPXRight1;
    private WPI_VictorSPX victorSPXRight2;
    private SpeedControllerGroup speedControllerRight;
    private DifferentialDrive rD;
    public  AHRS ahrs;
    private double divisor = 1.5;
    private static boolean squaredInputs = true;
    public  Encoder sDriveencRight;
    public  Encoder sDriveencLeft;
    private static final double  COUNTS_PER_INCH_RIGHT = 1000, COUNTS_PER_INCH_LEFT = 1000; //beta = 581.329
    public  boolean piSDDOkay = true;

    public sDrive() {
        //SmartDashboard.putBoolean("Use Xbox", false);
        SmartDashboard.putBoolean("Use Tank Drive", true);
        //SmartDashboard.putNumber("Drive Speed Divisor", divisor);
        SmartDashboard.putBoolean("Reset Drive Encoder", false);
        //System.out.println("sDrive Start");

        talonSRXLeft3  = new WPI_TalonSRX(4);
        victorSPXLeft4 = new WPI_VictorSPX(14);
        victorSPXLeft5 = new WPI_VictorSPX(15);
        speedControllerLeft = new SpeedControllerGroup(talonSRXLeft3, victorSPXLeft4, victorSPXLeft5);
        speedControllerLeft.setInverted(true);
        addChild("Speed Controller Left",speedControllerLeft);
        
        talonSRXRight0  = new WPI_TalonSRX(3);
        victorSPXRight1 = new WPI_VictorSPX(6);
        victorSPXRight2 = new WPI_VictorSPX(7);
        speedControllerRight = new SpeedControllerGroup(talonSRXRight0, victorSPXRight1, victorSPXRight2 );
        speedControllerRight.setInverted(true);
        addChild("Speed Controller Right",speedControllerRight);

        rD = new DifferentialDrive(speedControllerLeft,speedControllerRight);
        setExpiration();
        //watchdogOff();  // Does this get rid of the Watchdog error messages on stgartup?

        talonSRXLeft3.configContinuousCurrentLimit(30, 0);
        talonSRXLeft3.configPeakCurrentLimit(35, 0);
        talonSRXLeft3.configPeakCurrentDuration(10, 0);
        talonSRXLeft3.enableCurrentLimit(true);
        talonSRXLeft3.configOpenloopRamp(0); // DO NOT USE, BROKEN
                
        talonSRXRight0.configContinuousCurrentLimit(30, 0);
        talonSRXRight0.configPeakCurrentLimit(35, 0);
        talonSRXRight0.configPeakCurrentDuration(10, 0);
        talonSRXRight0.enableCurrentLimit(true);
        talonSRXRight0.configOpenloopRamp(0); // DO NOT USE, BROKEN
        
        victorSPXRight1.follow(talonSRXRight0);
        victorSPXRight2.follow(talonSRXRight0);
        victorSPXLeft4.follow(talonSRXLeft3);
        victorSPXLeft5.follow(talonSRXLeft3);
        setBrake();
        //setCoast();

        try {
        	ahrs = new AHRS(SerialPort.Port.kUSB);//SerialPort.Port.kUSB I2C.Port.kOnboard SerialPort.Port.kMXP
        	
        } catch (RuntimeException ex ) {
            System.out.println("RobotMap IMU not connected");
        }
        sDriveencRight = new Encoder(2,3);// yes the numbers are backwards, simple electrical fix later 
        sDriveencRight.setDistancePerPulse(1 / COUNTS_PER_INCH_RIGHT);
        sDriveencRight.setSamplesToAverage(20);
        sDriveencRight.reset();
        sDriveencRight.setReverseDirection(true);

        sDriveencLeft = new Encoder(0,1);
        sDriveencLeft.setDistancePerPulse(1 / COUNTS_PER_INCH_LEFT);  // actually measure COUNTS PER INCH LEFT  ASAP
        sDriveencLeft.setSamplesToAverage(20);
        sDriveencLeft.reset();
        sDriveencLeft.setReverseDirection(false);
    }

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new Driving()); //  WHEN USING HEIGHTCORRECTING COMMENT OUT
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    public void jSDrive(double left, double right)
    {
        speedControllerLeft.set(left);
        speedControllerRight.set(right);
    }
    
    public void jSTankdrive(double left, double right)
    {
        rD.tankDrive(left, right, squaredInputs); // joystick inputs squared 
        //System.out.println("left = "+left+" right = "+right);
    }
    
    public void jSArcadedrive(double speed, double rotation)
    {
        rD.arcadeDrive(speed, rotation, squaredInputs);
    }
    
    public void setBrake() {
    	talonSRXLeft3.setNeutralMode(NeutralMode.Brake);
        talonSRXRight0.setNeutralMode(NeutralMode.Brake);
        victorSPXRight1.setNeutralMode(NeutralMode.Brake);
        victorSPXRight2.setNeutralMode(NeutralMode.Brake);
        victorSPXLeft4.setNeutralMode(NeutralMode.Brake);
        victorSPXLeft5.setNeutralMode(NeutralMode.Brake);
    }
    
    public void setCoast() {
        talonSRXLeft3.setNeutralMode(NeutralMode.Coast);
        talonSRXRight0.setNeutralMode(NeutralMode.Coast);
        victorSPXRight1.setNeutralMode(NeutralMode.Coast);
        victorSPXRight2.setNeutralMode(NeutralMode.Coast);
        victorSPXLeft4.setNeutralMode(NeutralMode.Coast);
        victorSPXLeft5.setNeutralMode(NeutralMode.Coast);
    }
    public float getYaw() {
        return ahrs.getYaw();
    }
    
    public float getPitch() {
        return ahrs.getPitch(); 
    }

    public float getRoll() {
        return ahrs.getRoll();
    }
    
    public double getDistance() {
        return sDriveencRight.getDistance();
    }

    public double getLeftDistance() {
        //SmartDashboard.putNumber("STA", sDriveencRight.getSamplesToAverage());
        return sDriveencLeft.getDistance();
    }

    public double getVelocity() {
        //SmartDashboard.putNumber("STA", sDriveencRight.getSamplesToAverage());
        return sDriveencRight.getRate();
    }

    public double getLeftVelocity() {
        //SmartDashboard.putNumber("STA", sDriveencRight.getSamplesToAverage());
        return sDriveencLeft.getRate();
    }
    
    public double getDivisor() {
        divisor = 1; // Divisor Disabled
        //divisor = SmartDashboard.getNumber("Drive Speed Divisor",divisor);
        return divisor;
    }

    public void squareInputs() {
        squaredInputs = true;
    }

    public void regularInputs() {
        squaredInputs = false;
    }

    public void clearDriveEnc() {
        sDriveencRight.reset();
        sDriveencLeft.reset();
    }

    public void setExpiration() {
        rD.setSafetyEnabled(true);
        rD.setExpiration(.05);
    }
    
    public void watchdogOff() {
        rD.setSafetyEnabled(false);
    }
    
    public void resetYaw() {
        ahrs.zeroYaw();
    }
}

